## 다양한 연관관계 매핑

---

연관관계 매핑시 고려사항 3가지

1. 다중성
    
    : `@ManyToOne`, `@OneToMany`, `@OneToOne`, `@ManyToMany`
    
2. 단방향, 양방향
    - DB 테이블: 외래 키 하나로 양쪽 JOIN 가능. 방향 개념 X
    - 객체: 참조용 필드가 있는 쪽으로만 참조 가능. 한 쪽만 참조하면 단방향, 양 쪽이 서로 참조하면 양방향
3. 연관관계의 주인

### 다대일[N:1]

: 가장 많이 사용하는 연관관계이며 다대일의 반대는 일대다 관계!

→ 다대일 관계의 경우 외래키가  N 방향에 위치함. (MEMBER) 

외래키가 존재하는 MEMBER를 연관관계 매핑한다. `@ManyToOne`

### 일대다[1:N]

: 1 방향에서 외래키를 관리하고자 하는 경우(실무에서는 권장하지 않는 방식) `@OneToMany`

: 테이블에서는 TEAM에 외래키가 들어갈 수는 없음.

객체와 테이블의 차이 때문에 반대편 테이블의 외래 키를 관리하는 특이한 구조 → 어마어마한 단점 ,,,

<aside>
실제 쿼리문 작동 방식이 복잡 … 설계의 방식을 DB에 맞춰서

다대일 단방향 관계에 필요시 양방향 관계를 추가하는 방식을 권장!

</aside>

### 일대일[1:1]

: 일대일 관계는 그 반대도 일대일 관계. 주 테이블이나 대상 테이블에 외래키를 갖게 한다. `@OneToOne`

*→ 주 테이블에 외래키 vs 대상 테이블에 외래키 ??*

위의 경우는 주 테이블(MEMBER)에 외래키가 존재하는 방식.

- 주 테이블에 외래 키: 주 테이블에 외래 키를 두고 대상 테이블을 찾음. **주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인**할 수 있다는 장점이 있지만, **값이 없으면 외래 키에 null을 허용**한다는 단점이 있음.
- 대상 테이블에 외래 키: 대상 테이블에 외래키가 존재함. 주 테이블과 대상 테이블을 **일대일에서 일대다 관계로 변경할 때 테이블 구조를 유지**할 수 있다는 장점이 있지만, 프록시 기능의 한계로 지연 로딩으로 설정해도 **항상 즉시 로딩**된다는 단점이 있음.

### 다대다[N:N]

→ **편리해보이지만 실무에서 쓰면 안 됨** 관계형 데이터베이스는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없기 때문! (객체는 컬렉션을 사용해서 객체 2개로 다대다 관계 가능) 연결 테이블을 추가해서 일대다, 다대일 관계로 풀어내야함.

`@ManyToMany` 와 `@JoinColumn` 을 이용해서 나타낸다.

## 고급 매핑

---

<aside>
관계형 데이터베이스에는 상속 관계 개념은 없음! 슈퍼타입 서브타입 관계라는 모델링 기법이 객체의 상속과 유사함.

</aside>

### 상속관계 매핑

: 객체의 상속, 구조와 데이터베이스의 슈퍼타입 서브타입 관계를 매핑

슈퍼타입 서브타입 논리 모델 → 실제 물리 모델

- 1.  각각 테이블로 변환 (조인 전략) `JOINED`
    
- 2.  통합 테이블로 변환 (단일 테이블 전략) `SINGLE_TABLE`
    
- 3.  서브타입 테이블로 변환 (구현 클래스마다 테이블 전략) `TABLE_PER_CLASS`
    

```java
@Entity
@Inheritance(strategy = InheritanceType.JOINED)
@DiscriminatorColumn
public class Item {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
		private Long id;

		private String name;
		private int price;

}
```

`@Inheritance(strategy = InheritanceType.XXX)` : 어노테이션을 이용하여 세 가지 전략 중 하나를 선택하여 부모 클래스에 지정한다.

`@DiscriminatorColumn` : 부모 엔티티가 생성될 때 자식 클래스 이름에 해당하는 값이 채워져서  Insert 된다.

`@DiscriminatorValue` : 자식 클래스에서 어노테이션으로 부모 엔티티가 생성될 때 입력될 값을 직접 지정한다. 디폴트 값은 엔티티명

- 조인 전략
    - 테이블 정규화가 가능하고, 외래키 참조 무결성 제약조건 활용가능하며 저장공간 효율화 가능.
    - 조회 시 JOIN을 많이 사용하여 성능이 저하되며 조회 쿼리가 복잡하고 데이터 저장 시 부모, 자식 테이블에 각각 INSERT 해야함.
- 단일 테이블 전략
    - JOIN이 필요 없으므로 조회 성능이 빠르고 조회 쿼리가 단순함.
    - 자식 엔티티가 매핑한 컬럼은 모두 null을 허용하고 테이블이 커질 수 있으므로 조회 성능이 느려질 수 있음.
- 구현 클래스마다 테이블 전략 → 쓰면 안 되는 전략 ,,, DB 전문가와 ORM 전문가 모두 추천하지 않음
    - 서브 타입을 명확하게 구분 가능, not null 가능.
    - 여러 테이블을 함께 조회할 때 UNION으로 모두 조회하여 성능이 느리고 자식 테이블을 통합해서 쿼리하기 어려움.

### `@MappedSuperclass`

→ 단순히 객체 관점에서 공통된 속성을 부모 클래스에 두고 자식 클래스에서 상속 받아서 사용하고 싶을 경우 사용하는 어노테이션 !

ex 등록일, 수정일, 등록자, 수정자 같은 공통으로 적용하는 정보

<aside>
`@Entity` 클래스는 엔티티나 `@MappedSuperclass`로 지정한 클래스만 상속 가능함!

</aside>

## 프록시와 연관관계 관리

---

엔티티에 있는 필드가 모두 필요한 경우에는 DB에서 전체 조회하여 필드 값을 가져오면 되지만, 

특정 필드 값만 필요한 경우에는 나머지 필드 까지 같이 가져오는 것은 비효율적! → 최적화x

### `em.getReference()`

: 데이터 베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회. 실제 쿼리문이 실행되지 않는다.

→ `em.getReference()` 호출 시 진짜 객체를 반환하는 것이 아니라 가짜(프록시) 엔티티를 반환한다. 내부의 target이 가르키는 것이 실제 엔티티.

### **프록시 특징**

실제 클래스를 상속 받아 겉 모양이 같음! 사용자 입장에서는 진짜 객체와 프록시 객체를 구분하지 않고 사용.

프록시 객체는 실제 객체의 참조(target)를 보관함. 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드를 호출하여 target에 담아 반환한다.

ex 아래 코드 실행 시 프록시 작동 원리

```java
Member member = em.getReference(Member.class, “id1”);

member.getName();
```

→ `getName()` 호출 시에 프록시에 target이 비어있으면 영속성 컨텍스트에 초기화를 요청한다. 이 때 실제 DB에서 조회하여 엔티티를 생성하고 그 뒤에 target에 담아 `getName()`을 호출한다.

**중요**

- 프록시 객체는 **처음 사용할 때 한 번만** 초기화하여 사용한다.
- 프록시 객체를 초기화할 때 프록시 객체가 **실제 엔티티로 바뀌는 것이 아니다**! 초기화 되면 프록시 객체를 통해서 실제 엔티티에 접근할 수 있다.
- 프록시 객체는 원본 엔티티를 **상속**받는다. 따라서 타입 체크 시에 `==`비교보다 `instance of`를 사용하는 것이 적절하다.
- **영속성 컨텍스트**에 찾고자 하는 엔티티가 이미 있으면 `em.getReference()`를 호출해도 **실제 엔티티**를 반환한다.
- 영속성 컨텍스트의 도움을 받을 수 없는 **준영속** 상태일 때, 프록시를 초기화 하면 문제가 발생한다.

**프록시 확인을 도와주는 유틸리티 메소드**

`PersistenceUnitUtil.isLoaded(Object entity)` : 프록시 인스턴스의 초기화 여부를 확인

`entity.getClass().getName()` : 프록시 클래스 확인

`org.hibernate.Hibernate.initialize(entity);` : 프록시 강제 초기화

⇒ JPA 표준은 강제 초기화 없음 

<aside>
지금까지 프록시에 대해 열심히 알아보았으나 ,,, 실제로 getReference()를 직접 사용하진 X
프록시 개념을 통해 즉시 로딩과 지연 로딩을 이해하기 위해 ,,,

</aside>

### 즉시 로딩과 지연 로딩

→ 지연 로딩(LAZY)과 즉시 로딩(EAGER)

```java
Member member = em.find(Member.class, 1L);
//Member 엔티티에 Team이 지연 로딩 설정되어 있으면 가짜 프록시 객체를 받아 놓는다.

Team team = member.getTeam();
team.getName();.
//실제 team을 "사용"하는 시점에 초기화가 일어난다.
```

Member와 Team을 함께 사용하는 일이 잦은 경우?

→ **즉시 로딩 EAGER**를 사용하여 함께 조회!

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/ac1945e1-fcda-46c8-b7ff-3a50be7629b5/dffa1748-3659-4928-8bbf-047d21c353b5/Untitled.png)

ex Member.class 

```java
@ManyToOne(fetch = FetchType.EAGER)
@JoinColumn(name = "TEAM_ID")
private Team team;
```

<aside>
가급적 **지연 로딩**만 사용하자(특히 실무에서)
→ 즉시 로딩을 적용하면 예상하지 못한 SQL이 발생함!
→ 즉시 로딩은 JPQL에서 N+1 문제를 일으킴.

`@ManyToOne`, `@OneToOne`은 기본이 즉시 로딩이므로 **LAZY로 설정**!
(`@OneToMany`, `@ManyToMany`는 기본이 지연 로딩)

</aside>

**결론: 즉시 로딩 쓰지 말 것 ,,,**

### 영속성 전이(CASCADE)

: 특정 엔티티를 영속 상태로 만들 때 **연관된 엔티티도 함께** 영속 상태로 만들고 싶을 때 사용

※영속성 전이는 연관관계를 매핑하는 것과 아무 관련이 없음※

하나의 부모가 자식을 관리할 때 쓰면 된다. 즉, 소유자가 하나일 때는 사용해도 되지만 특정 자식이 여러 엔티티에 소유되어 있을 때는 사용하면 안 됨!

**CASCADE의 종류**

→ **ALL**(모두 적용), **PERSIST**(영속), **REMOVE**(삭제), **MERGE**(병합), **REFRESH**, **DETACH**

### 고아 객체

: 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제

→ `orphanRemoval = true`

**언제 사용할까?**

: 참조하는 곳이 하나일 때 사용해야함 !!

**`CascadeType.ALL + orphanRemovel = true`**

→ 두 옵션을 모두 활성화 하면 부모 엔티티를 통해서 자식의 생명 주기를 관리할 수 있음!